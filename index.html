<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drum Tuner</title>
    <meta
      name="description"
      content="Afinador de batería web que utiliza el micrófono para detectar la afinación de los tambores."
    />
    <link rel="icon" href="icon-192.png" sizes="192x192" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- TensorFlow.js para detección de pitch basada en IA -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
    <!-- Librería CREPE para detección de pitch con IA -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    <script src="https://unpkg.com/@tensorflow-models/pitch-detection@0.0.5/dist/pitch-detection.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        -webkit-tap-highlight-color: transparent;
      }

      :root {
        --glow-success: rgba(52, 211, 153, 0.7);
        --glow-warning: rgba(239, 68, 68, 0.6);
      }

      .tuner-circle {
        transition: all 0.3s ease-in-out;
        position: relative;
        backdrop-filter: blur(8px);
      }

      .tuner-circle::before {
        content: "";
        position: absolute;
        inset: -2px;
        border-radius: 50%;
        padding: 2px;
        background: linear-gradient(45deg, #2dd4bf, #10b981);
        -webkit-mask: linear-gradient(#fff 0 0) content-box,
          linear-gradient(#fff 0 0);
        mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        opacity: 0.7;
        transition: opacity 0.3s ease;
      }

      .tuner-needle {
        transform-origin: bottom center;
        transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: 0 0 15px rgba(52, 211, 153, 0.8);
        filter: drop-shadow(0 0 8px rgba(52, 211, 153, 0.6));
        position: relative;
      }

      .tuner-needle::after {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to top,
          rgba(52, 211, 153, 0.9),
          rgba(16, 185, 129, 0.5)
        );
        border-radius: 2px;
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
      }

      /* Pulsación cuando está afinado */
      @keyframes tuned-pulse {
        0%,
        100% {
          filter: drop-shadow(0 0 15px rgba(52, 211, 153, 0.8));
          transform: scaleY(1);
        }
        50% {
          filter: drop-shadow(0 0 25px rgba(16, 185, 129, 1));
          transform: scaleY(1.02);
        }
      }

      .tuner-needle.tuned {
        animation: tuned-pulse 0.6s ease-in-out infinite;
      }

      /* Vibración cuando está desafinado */
      @keyframes out-of-tune {
        0%,
        100% {
          filter: drop-shadow(0 0 15px rgba(239, 68, 68, 0.6));
        }
        50% {
          filter: drop-shadow(0 0 25px rgba(220, 38, 38, 0.9));
        }
      }

      .tuner-needle.out-of-tune {
        animation: out-of-tune 0.4s ease-in-out infinite;
      }

      .note-flat {
        box-shadow: 0 0 25px 5px var(--glow-warning);
      }
      .note-flat::before {
        background: linear-gradient(45deg, #f87171, #ef4444);
      }

      .note-sharp {
        box-shadow: 0 0 25px 5px var(--glow-warning);
      }
      .note-sharp::before {
        background: linear-gradient(45deg, #f87171, #ef4444);
      }

      .note-in-tune {
        box-shadow: 0 0 30px 10px var(--glow-success);
      }
      .note-in-tune::before {
        background: linear-gradient(45deg, #34d399, #10b981);
        opacity: 1;
      }

      /* Animaciones para las transiciones de estado */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
        100% {
          transform: scale(1);
        }
      }

      .note-in-tune .tuner-needle {
        animation: pulse 1s ease-in-out infinite;
      }
    </style>
  </head>

  <body
    class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-2 select-none"
  >
    <div
      class="w-full max-w-md mx-auto bg-gray-800 rounded-2xl shadow-2xl p-3 sm:p-4 space-y-3"
    >
      <header class="text-center">
        <h1 class="text-2xl sm:text-3xl font-bold text-emerald-400">
          Afinador de Batería
        </h1>
      </header>

      <!-- Selector de Tambor -->
      <div class="flex items-center justify-center space-x-2 mb-3">
        <label for="drum-select" class="text-gray-400">Tambor:</label>
        <select
          id="drum-select"
          class="bg-gray-700 text-white rounded-md py-2 px-3"
        >
          <option value="kick">Bombo</option>
          <option value="snare">Tarola</option>
          <option value="tom-high">Tom Alto</option>
          <option value="tom-mid">Tom Medio</option>
          <option value="tom-floor">Tom de Piso</option>
        </select>
      </div>

      <!-- Selector de Nota -->
      <div class="flex items-center justify-center space-x-2">
        <label for="note-select" class="text-gray-400">Nota:</label>
        <select
          id="note-select"
          class="bg-gray-700 text-white rounded-md py-2 px-3"
        >
          <option value="C">C</option>
          <option value="C#">C#</option>
          <option value="D">D</option>
          <option value="D#">D#</option>
          <option value="E">E</option>
          <option value="F">F</option>
          <option value="F#">F#</option>
          <option value="G">G</option>
          <option value="G#">G#</option>
          <option value="A">A</option>
          <option value="A#">A#</option>
          <option value="B">B</option>
        </select>

        <label for="octave-select" class="text-gray-400">Octava:</label>
        <select
          id="octave-select"
          class="bg-gray-700 text-white rounded-md py-2 px-3"
        >
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </div>

      <!-- Descripción del Tambor -->
      <div class="text-center mt-2">
        <p id="drum-description" class="text-sm text-gray-400 italic"></p>
      </div>

      <!-- Visualizador del Afinador -->
      <div class="relative flex flex-col items-center justify-center space-y-4">
        <!-- Nota Objetivo -->
        <div class="text-center">
          <span class="text-gray-400 text-sm">NOTA OBJETIVO</span>
          <p
            id="target-note-display"
            class="text-3xl font-bold text-emerald-300"
          >
            -
          </p>
        </div>

        <!-- Círculo del Afinador -->
        <div
          id="tuner-circle"
          class="tuner-circle relative w-64 h-64 sm:w-72 sm:h-72 bg-gray-900 rounded-full flex items-center justify-center border-4 border-gray-700"
        >
          <!-- Marcadores y Escala -->
          <div class="absolute top-0 h-full w-full">
            <!-- Marcador Central -->
            <div
              class="h-6 w-0.5 bg-emerald-400 absolute top-2 left-1/2 -translate-x-1/2"
            ></div>

            <!-- Marcadores Laterales -->
            <div class="absolute w-full h-full">
              <!-- -30 cents -->
              <div
                class="absolute left-[25%] top-[15%] h-4 w-0.5 bg-gray-500 transform -rotate-30"
              >
                <span class="absolute -left-4 -top-6 text-xs text-gray-400"
                  >-30</span
                >
              </div>

              <!-- -15 cents -->
              <div
                class="absolute left-[37.5%] top-[10%] h-3 w-0.5 bg-gray-500 transform -rotate-15"
              >
                <span class="absolute -left-4 -top-6 text-xs text-gray-400"
                  >-15</span
                >
              </div>

              <!-- +15 cents -->
              <div
                class="absolute right-[37.5%] top-[10%] h-3 w-0.5 bg-gray-500 transform rotate-15"
              >
                <span class="absolute -right-4 -top-6 text-xs text-gray-400"
                  >+15</span
                >
              </div>

              <!-- +30 cents -->
              <div
                class="absolute right-[25%] top-[15%] h-4 w-0.5 bg-gray-500 transform rotate-30"
              >
                <span class="absolute -right-4 -top-6 text-xs text-gray-400"
                  >+30</span
                >
              </div>

              <!-- Línea de referencia -->
              <div
                class="absolute w-full h-0.5 bg-gradient-to-r from-transparent via-gray-600 to-transparent top-[20%]"
              ></div>
            </div>
          </div>
          <!-- Aguja -->
          <div
            id="tuner-needle"
            class="tuner-needle w-1 h-32 sm:h-36 bg-emerald-400 rounded-t-full absolute bottom-1/2"
          ></div>
          <!-- Círculo central -->
          <div class="w-4 h-4 bg-gray-600 rounded-full z-10"></div>
        </div>

        <!-- Feedback de Afinación -->
        <div id="tuning-feedback" class="text-2xl font-semibold h-8">-</div>

        <!-- Nota Detectada -->
        <div class="flex flex-col items-center space-y-2">
          <!-- Nota Detectada con Animación -->
          <div class="relative">
            <p
              id="detected-note"
              class="text-6xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 to-teal-500"
            >
              -
            </p>
            <div
              class="absolute -inset-1 bg-gradient-to-r from-emerald-400/20 to-teal-500/20 blur opacity-50 group-hover:opacity-75 transition duration-200"
            ></div>
          </div>

          <!-- Frecuencia Detectada -->
          <div class="bg-gray-800/50 px-4 py-1 rounded-full backdrop-blur-sm">
            <p id="detected-freq" class="text-emerald-300 text-sm font-mono">
              -
            </p>
          </div>
        </div>
      </div>

      <!-- Botón de Control con Efecto -->
      <div class="text-center mt-6">
        <div class="relative inline-block group">
          <div
            class="absolute -inset-1 bg-gradient-to-r from-emerald-600 to-teal-600 rounded-full blur opacity-25 group-hover:opacity-50 transition duration-200"
          ></div>
          <button
            id="start-btn"
            class="relative bg-gradient-to-r from-emerald-500 to-teal-600 hover:from-emerald-600 hover:to-teal-700 text-white font-bold py-3 px-8 rounded-full transition-all duration-200 w-full max-w-xs shadow-lg hover:shadow-emerald-500/25"
          >
            Activar Micrófono
          </button>
        </div>
        <p id="error-message" class="text-red-400 mt-3 text-sm h-4 px-4"></p>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Elementos del DOM
        const startBtn = document.getElementById("start-btn");
        const targetNoteDisplay = document.getElementById(
          "target-note-display"
        );
        const tunerCircle = document.getElementById("tuner-circle");
        const tunerNeedle = document.getElementById("tuner-needle");
        const tuningFeedback = document.getElementById("tuning-feedback");
        const detectedNoteEl = document.getElementById("detected-note");
        const detectedFreqEl = document.getElementById("detected-freq");
        const errorMessage = document.getElementById("error-message");
        const noteSelect = document.getElementById("note-select");
        const octaveSelect = document.getElementById("octave-select");

        // Configuración del audio
        let audioContext;
        let analyser;
        let source;
        let mediaStream;
        let isListening = false;
        let animationFrameId;
        let pitchDetector = null;

        // Configuración del analizador
        const FFT_SIZE = 4096;
        const SAMPLE_RATE = 16000; // Optimal para TensorFlow pitch detection

        // Variables para la detección de tono
        let buffer;

        // Filtro pasa banda variables
        let lowFrequency = 20; // Frecuencia mínima para tambores (Hz)
        let highFrequency = 500; // Frecuencia máxima para tambores (Hz)
        let frequencyMargin = 15; // Margen de frecuencia más preciso (Hz)

        // Variables de umbral y detección
        let amplitudeThreshold = 0.02; // Umbral de amplitud reducido
        let silenceThreshold = 0.005;
        let isBelowThreshold = false;
        let belowThresholdStart = null;
        let silenceDurationThreshold = 50; // Reducido para mejor respuesta

        // Sistema de suavizado mejorado
        const HISTORY_SIZE = 8;
        let freqHistory = [];
        let confidenceHistory = [];
        let lastValidFreq = null;
        let confidenceScore = 0;

        // Inicializar el detector de pitch con TensorFlow
        const initPitchDetector = async () => {
          try {
            // Usar PitchDetection de TensorFlow
            if (typeof pitchDetection !== "undefined") {
              pitchDetector = pitchDetection.PitchDetection(
                mediaStream,
                audioContext
              );
              console.log("TensorFlow Pitch Detector inicializado");
            }
          } catch (err) {
            console.log("TensorFlow no disponible, usando método FFT");
          }
        };

        // Detección de pitch usando FFT como fallback
        const detectPitchFFT = (frequencyData) => {
          let maxValue = -Infinity;
          let maxFrequency = 0;

          for (let i = 0; i < frequencyData.length; i++) {
            if (frequencyData[i] > maxValue) {
              maxValue = frequencyData[i];
              maxFrequency = (i * SAMPLE_RATE) / (frequencyData.length * 2);
            }
          }

          return maxFrequency;
        };

        // Presets de tambores
        const drumPresets = {
          kick: {
            name: "Bombo",
            range: [30, 80],
            defaultNote: "E2",
            description: "Frecuencias bajas, generalmente entre E2-G2",
          },
          snare: {
            name: "Tarola",
            range: [150, 350],
            defaultNote: "D4",
            description: "Afinación media-alta, típicamente entre C4-E4",
          },
          "tom-high": {
            name: "Tom Alto",
            range: [130, 200],
            defaultNote: "G3",
            description: "Tom más agudo, generalmente entre F3-A3",
          },
          "tom-mid": {
            name: "Tom Medio",
            range: [100, 150],
            defaultNote: "D3",
            description: "Tom de afinación media, entre C3-E3",
          },
          "tom-floor": {
            name: "Tom de Piso",
            range: [65, 100],
            defaultNote: "A2",
            description: "Tom más grave, típicamente entre G2-B2",
          },
        };

        // Notas musicales
        const noteStrings = [
          "C",
          "C#",
          "D",
          "D#",
          "E",
          "F",
          "F#",
          "G",
          "G#",
          "A",
          "A#",
          "B",
        ];

        let currentNote = null;
        let currentOctave = null;
        let targetNoteInfo = null;

        // Variables para mantener la última nota y frecuencia detectadas
        let lastDetectedNote = "-";
        let lastDetectedFreq = "-";
        let lastTuningStatus = "-";
        let lastStatusColor = "text-gray-400";

        // Función para calcular el promedio ponderado
        const calculateWeightedAverage = (values) => {
          if (values.length === 0) return null;

          const weights = values.map((_, i) =>
            Math.pow(0.8, values.length - 1 - i)
          );
          const weightSum = weights.reduce((a, b) => a + b, 0);

          return (
            values.reduce((sum, value, i) => sum + value * weights[i], 0) /
            weightSum
          );
        };

        // --- Funciones Principales ---

        const updateTargetNote = () => {
          currentNote = noteSelect.value;
          currentOctave = octaveSelect.value;
          const targetNoteString = `${currentNote}${currentOctave}`;
          targetNoteInfo = getNoteDetails(targetNoteString);

          if (targetNoteInfo) {
            targetNoteDisplay.textContent = `${targetNoteInfo.note}${
              targetNoteInfo.octave
            } (${targetNoteInfo.frequency.toFixed(1)} Hz)`;

            // Actualizar frecuencias de corte del filtro
            lowFrequency = Math.max(
              20,
              targetNoteInfo.frequency - frequencyMargin
            ); // Mínimo 20Hz
            highFrequency = targetNoteInfo.frequency + frequencyMargin;
          } else {
            targetNoteDisplay.textContent = "-";
            lowFrequency = 80;
            highFrequency = 300;
          }

          resetTuner();
        };

        const toggleListening = async () => {
          if (isListening) {
            stopListening();
          } else {
            await startListening();
          }
        };

        const startListening = async () => {
          if (!currentNote || !currentOctave) {
            errorMessage.textContent =
              "Por favor, selecciona una nota y octava primero.";
            setTimeout(() => (errorMessage.textContent = ""), 3000);
            return;
          }

          errorMessage.textContent = "";

          try {
            if (!audioContext) {
              audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();
            }
            if (audioContext.state === "suspended") {
              await audioContext.resume();
            }

            mediaStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
              },
              video: false,
            });
            source = audioContext.createMediaStreamSource(mediaStream);

            // Conectar directamente al analizador sin filtros
            analyser = audioContext.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            analyser.smoothingTimeConstant = 0.3;
            source.connect(analyser);

            buffer = new Float32Array(FFT_SIZE);

            // Inicializar detector de pitch con TensorFlow
            await initPitchDetector();

            isListening = true;
            startBtn.textContent = "Detener";
            startBtn.classList.replace("bg-emerald-600", "bg-red-600");
            startBtn.classList.replace(
              "hover:bg-emerald-700",
              "hover:bg-red-700"
            );

            analyze();
          } catch (err) {
            console.error("Error al acceder al micrófono:", err);
            errorMessage.textContent = "No se pudo acceder al micrófono.";
          }
        };

        const stopListening = () => {
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
          }
          if (mediaStream) {
            mediaStream.getTracks().forEach((track) => track.stop());
          }
          if (source) {
            source.disconnect();
          }

          isListening = false;
          startBtn.textContent = "Activar Micrófono";
          startBtn.classList.replace("bg-red-600", "bg-emerald-600");
          startBtn.classList.replace(
            "hover:bg-red-700",
            "hover:bg-emerald-700"
          );
          resetTuner();
        };

        const analyze = () => {
          analyser.getFloatTimeDomainData(buffer);

          // Calcular RMS
          const rms = Math.sqrt(
            buffer.reduce((s, v) => s + v * v, 0) / buffer.length
          );

          let fundamentalFreq = null;

          // Aplicar puerta de amplitud
          if (rms > amplitudeThreshold) {
            if (isBelowThreshold) {
              isBelowThreshold = false;
              belowThresholdStart = null;
            }

            // Obtener datos de frecuencia
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(frequencyData);

            // Usar FFT para detectar el pitch
            let detectedFreq = detectPitchFFT(frequencyData);

            // Validar que la frecuencia está en el rango esperado
            if (
              detectedFreq > 0 &&
              detectedFreq >= lowFrequency &&
              detectedFreq <= highFrequency
            ) {
              // Agregar la nueva frecuencia al historial
              freqHistory.push(detectedFreq);
              confidenceHistory.push(0.8); // Confianza moderada para FFT

              if (freqHistory.length > HISTORY_SIZE) {
                freqHistory.shift();
                confidenceHistory.shift();
              }

              // Calcular el promedio ponderado
              const avgFreq = calculateWeightedAverage(freqHistory);
              if (avgFreq !== null) {
                fundamentalFreq = avgFreq;

                // Calcular confianza promedio
                confidenceScore =
                  confidenceHistory.reduce((a, b) => a + b, 0) /
                  confidenceHistory.length;
              }

              lastValidFreq = fundamentalFreq;
            } else {
              fundamentalFreq = null;
            }
          } else {
            if (!isBelowThreshold) {
              isBelowThreshold = true;
              belowThresholdStart = performance.now();
            } else if (
              performance.now() - belowThresholdStart >
              silenceDurationThreshold
            ) {
              fundamentalFreq = null;
              lastValidFreq = null;
              freqHistory = [];
              confidenceHistory = [];
            }
          }

          if (fundamentalFreq) {
            updateUI(fundamentalFreq);
          } else {
            detectedNoteEl.textContent = lastDetectedNote;
            detectedFreqEl.textContent = lastDetectedFreq;
            tuningFeedback.textContent = lastTuningStatus;
            tuningFeedback.className = `text-2xl font-semibold h-8 ${lastStatusColor}`;
            resetTuner();
          }

          animationFrameId = requestAnimationFrame(analyze);
        };

        const updateUI = (freq) => {
          const noteInfo = frequencyToNoteDetails(freq);
          const centsOff = calculateCents(freq, targetNoteInfo.frequency);

          detectedNoteEl.textContent = `${noteInfo.note}${noteInfo.octave}`;

          // Mostrar frecuencia y confianza
          const confidencePercent = Math.round(confidenceScore * 100);
          detectedFreqEl.textContent = `${freq.toFixed(
            1
          )} Hz (${confidencePercent}%)`;

          // Actualizar las últimas notas detectadas
          lastDetectedNote = `${noteInfo.note}${noteInfo.octave}`;
          lastDetectedFreq = `${freq.toFixed(1)} Hz`;

          let status = "";
          let statusColor = "";
          let circleClass = "";

          // Solo mostrar feedback si la nota detectada es la correcta
          if (
            noteInfo.note === targetNoteInfo.note &&
            noteInfo.octave === targetNoteInfo.octave
          ) {
            // Calcular rotación de la aguja con mayor rango
            let rotation = 0;
            if (Math.abs(centsOff) <= 50) {
              rotation = centsOff * 0.8; // Máximo ±40 grados para ±50 cents
            } else {
              rotation = Math.sign(centsOff) * 40;
            }

            tunerNeedle.style.transform = `rotate(${rotation}deg)`;

            // Clasificación de afinación
            if (Math.abs(centsOff) < 5) {
              // Afinado
              status = "✓ Afinado";
              statusColor = "text-emerald-400";
              circleClass = "note-in-tune";
              tunerNeedle.classList.remove("out-of-tune");
              tunerNeedle.classList.add("tuned");
            } else if (centsOff < -5) {
              // Muy bajo
              if (centsOff < -20) {
                status = "▼▼ Muy bajo";
              } else {
                status = "▼ Bajo";
              }
              statusColor = "text-orange-400";
              circleClass = "note-flat";
              tunerNeedle.classList.remove("tuned");
              tunerNeedle.classList.add("out-of-tune");
            } else {
              // Muy alto
              if (centsOff > 20) {
                status = "▲▲ Muy alto";
              } else {
                status = "▲ Alto";
              }
              statusColor = "text-orange-400";
              circleClass = "note-sharp";
              tunerNeedle.classList.remove("tuned");
              tunerNeedle.classList.add("out-of-tune");
            }
          } else {
            // Si la nota es incorrecta
            status = "Nota incorrecta";
            statusColor = "text-yellow-400";
            tunerNeedle.style.transform = "rotate(0deg)";
            tunerNeedle.classList.remove("tuned", "out-of-tune");
          }

          tuningFeedback.textContent = status;
          tuningFeedback.className = `text-2xl font-semibold h-8 ${statusColor}`;
          tunerCircle.className = `tuner-circle relative w-64 h-64 sm:w-72 sm:h-72 bg-gray-900 rounded-full flex items-center justify-center border-4 border-gray-700 ${circleClass}`;

          // Actualizar el último estado
          lastTuningStatus = status;
          lastStatusColor = statusColor;
        };

        const resetTuner = () => {
          tunerNeedle.style.transform = "rotate(0deg)";
          tuningFeedback.textContent = "-";
          tuningFeedback.className = "text-2xl font-semibold h-8";
          tunerCircle.className = `tuner-circle relative w-64 h-64 sm:w-72 sm:h-72 bg-gray-900 rounded-full flex items-center justify-center border-4 border-gray-700`;
        };

        // --- Funciones de Cálculo ---

        const frequencyToNoteDetails = (frequency) => {
          const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
          const roundedNote = Math.round(noteNum) + 69;
          const octave = Math.floor(roundedNote / 12) - 1;
          const noteIndex = roundedNote % 12;
          return {
            note: noteStrings[noteIndex],
            octave: octave,
          };
        };

        const getNoteDetails = (noteString) => {
          const noteRegex = /^([A-G]#?)([0-9])$/;
          const match = noteString.match(noteRegex);
          if (!match) return null;

          const noteName = match[1];
          const octave = parseInt(match[2], 10);

          const noteIndex = noteStrings.indexOf(noteName);
          const noteNum = noteIndex + (octave + 1) * 12;

          const frequency = 440 * Math.pow(2, (noteNum - 69) / 12);

          return { note: noteName, octave, frequency };
        };

        const calculateCents = (freq1, freq2) => {
          return 1200 * Math.log2(freq1 / freq2);
        };

        // --- Event Listeners ---
        startBtn.addEventListener("click", toggleListening);
        noteSelect.addEventListener("change", updateTargetNote);
        octaveSelect.addEventListener("change", updateTargetNote);

        const drumSelect = document.getElementById("drum-select");

        const updateDrumPreset = () => {
          const selectedDrum = drumPresets[drumSelect.value];

          // Actualizar rangos de frecuencia
          lowFrequency = selectedDrum.range[0];
          highFrequency = selectedDrum.range[1];

          // Establecer la nota predeterminada
          const [note, octave] = selectedDrum.defaultNote
            .match(/([A-G]#?)(\d)/)
            .slice(1);
          noteSelect.value = note;
          octaveSelect.value = octave;

          // Actualizar la nota objetivo
          updateTargetNote();

          // Mostrar descripción del tambor
          const descriptionEl = document.getElementById("drum-description");
          if (descriptionEl) {
            descriptionEl.textContent = selectedDrum.description;
          }
        };

        // Event listeners
        drumSelect.addEventListener("change", updateDrumPreset);

        // Inicializar con el primer tambor
        updateDrumPreset();
      });
    </script>
  </body>
</html>
