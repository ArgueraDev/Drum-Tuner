<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drum Tuner</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1e1e1e">
    <style>
        /* Estilos generales */
        body {
            font-family: Arial, sans-serif;
            background: #121212;
            color: #fff;
            text-align: center;
            padding: 20px;
        }

        h1 {
            color: #FFD700;
        }

        select,
        input {
            padding: 8px;
            margin: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
            background-color: #333;
            color: #fff;
        }

        /* Estilos para el medidor tipo afinador de guitarra */
        #meter {
            width: 300px;
            height: 150px;
            background: rgba(51, 51, 51, 0.5);
            margin: 20px auto;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 5px;
        }

        #indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 5px;
            height: 130px;
            background: #4caf50;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.1s;
        }

        /* Rango de frecuencia visual */
        #frequencyRange {
            position: absolute;
            top: 10px;
            left: 2px;
            width: 300px;
            height: 130px;
            display: flex;
            justify-content: space-between;
            padding-right: 2px;
        }

        #frequencyRange span {
            color: #fff;
            font-size: 12px;
            position: relative;
            bottom: 0;
            text-shadow: 0 0 5px #000;
        }

        #status {
            font-size: 20px;
            margin-top: 10px;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>

<body>

    <h1>Drum Tuner</h1>

    <label>Tonalidad:</label>
    <select id="drumPreset">
        <option value="44">Bombo â†’ F1 (44 Hz)</option>
        <option value="46">Bombo R â†’ F#1 (46 Hz)</option>
        <option value="98">Tom 3 â†’ G2 (98 Hz)</option>
        <option value="104">Tom 3 R â†’ G#2 (104 Hz)</option>
        <option value="131">Tom 2 â†’ C3 (131 Hz)</option>
        <option value="139">Tom 2 R â†’ C#3 (139 Hz)</option>
        <option value="165">Tom 1 â†’ E3 (165 Hz)</option>
        <option value="175">Tom 1 R â†’ F3 (175 Hz)</option>
        <option value="220">Caja â†’ A3 (220 Hz)</option>
        <option value="247">Caja R â†’ B3 (247 Hz)</option>
    </select>

    <div id="meter">
        <div id="indicator"></div>
        <div id="frequencyRange">
            <span>-50 Hz</span>
            <span>0 Hz</span>
            <span>+50 Hz</span>
        </div>
    </div>

    <div id="status"></div>

    <script>
        // Define la frecuencia objetivo inicial
        let targetFrequency = 60;

        // Escucha los cambios en el selector de presets de baterÃ­a
        document.getElementById('drumPreset').addEventListener('change', e => {
            // Actualiza la frecuencia objetivo con el valor seleccionado
            targetFrequency = parseFloat(e.target.value);
        });

        // FunciÃ³n para solicitar permiso para usar el micrÃ³fono
        function requestMicrophonePermission() {
            // Utiliza la API de MediaDevices para acceder al micrÃ³fono
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    // Permiso concedido

                    // Crea un contexto de audio
                    const audioContext = new AudioContext();

                    // Crea una fuente de audio a partir del stream del micrÃ³fono
                    const source = audioContext.createMediaStreamSource(stream);

                    // Crea un analizador de audio
                    const analyser = audioContext.createAnalyser();

                    // Establece el tamaÃ±o de la FFT (Fast Fourier Transform)
                    analyser.fftSize = 2048;

                    // Conecta la fuente al analizador
                    source.connect(analyser);

                    // Crea un buffer para almacenar los datos del analizador
                    const buffer = new Float32Array(analyser.fftSize);

                    // Variables para el cÃ¡lculo del pitch
                    let lastPitch = null;
                    let lastHitTime = 0;
                    const minTimeBetweenHits = 300; // milisegundos
                    let lastRotation = 0; // Agrega esta lÃ­nea

                    // FunciÃ³n para obtener la nota a partir de la frecuencia
                    function getNoteFromFrequency(frequency) {
                        const A4 = 440;
                        const noteNames = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
                        const noteNum = 12 * (Math.log(frequency / A4) / Math.log(2));
                        const note = Math.round(noteNum) + 69;
                        return noteNames[(note - 1) % 12] + Math.floor((note + 9) / 12);
                    }

                    // FunciÃ³n para realizar la autocorrelaciÃ³n y detectar el pitch
                    function autoCorrelate(buf, sampleRate) {
                        let SIZE = buf.length;
                        let MAX_SAMPLES = Math.floor(SIZE / 2);
                        let bestOffset = -1;
                        let bestCorrelation = 0;
                        let rms = 0;
                        let foundGoodCorrelation = false;
                        let correlations = new Array(MAX_SAMPLES);

                        for (let i = 0; i < SIZE; i++) {
                            let val = buf[i];
                            rms += val * val;
                        }
                        rms = Math.sqrt(rms / SIZE);

                        // ðŸ”¹ Filtrar ruido subiendo el umbral
                        if (rms < 0.03) return -1;

                        let lastCorrelation = 1;
                        for (let offset = 0; offset < MAX_SAMPLES; offset++) {
                            let correlation = 0;
                            for (let i = 0; i < MAX_SAMPLES; i++) {
                                correlation += Math.abs((buf[i]) - (buf[i + offset]));
                            }
                            correlation = 1 - (correlation / MAX_SAMPLES);
                            correlations[offset] = correlation;
                            if ((correlation > 0.9) && (correlation > lastCorrelation)) {
                                foundGoodCorrelation = true;
                                if (correlation > bestCorrelation) {
                                    bestCorrelation = correlation;
                                    bestOffset = offset;
                                }
                            } else if (foundGoodCorrelation) {
                                let shift = (correlations[bestOffset + 1] - correlations[bestOffset - 1]) / correlations[bestOffset];
                                return sampleRate / (bestOffset + (8 * shift));
                            }
                            lastCorrelation = correlation;
                        }
                        if (bestCorrelation > 0.01) {
                            return sampleRate / bestOffset;
                        }
                        return -1;
                    }

                    // FunciÃ³n principal de actualizaciÃ³n
                    function update() {
                        // Obtiene los datos del analizador
                        analyser.getFloatTimeDomainData(buffer);

                        // Calcula el pitch utilizando la funciÃ³n de autocorrelaciÃ³n
                        let pitch = autoCorrelate(buffer, audioContext.sampleRate);

                        // Obtiene los elementos del DOM
                        const indicator = document.getElementById('indicator');
                        const status = document.getElementById('status');

                        let now = Date.now();

                        // ðŸ”¹ Filtrar por rango de frecuencia
                        if (pitch !== -1 && pitch > targetFrequency * 0.5 && pitch < targetFrequency * 1.5) {
                            if (now - lastHitTime > minTimeBetweenHits) {
                                lastPitch = pitch;
                                lastHitTime = now;
                            }
                        }

                        if (lastPitch !== null) {
                            let diff = lastPitch - targetFrequency;
                            // Calcula el Ã¡ngulo de rotaciÃ³n basado en la diferencia de frecuencia
                            let rotation = Math.min(Math.max(diff * 0.5, -45), 45);
                            // Rango de -45 a +45 grados

                            // Aplica suavizado
                            const smoothingFactor = 0.2; // Ajusta este valor para controlar el suavizado
                            rotation = lastRotation * (1 - smoothingFactor) + rotation * smoothingFactor;
                            lastRotation = rotation;

                            indicator.style.transform = `translateX(-50%) rotate(${rotation}deg)`;

                            const note = getNoteFromFrequency(lastPitch);
                            if (Math.abs(diff) < 1) {
                                indicator.style.background = "#4caf50";
                                status.innerHTML = `ðŸŽ¯ ${lastPitch.toFixed(2)} Hz - ${note} â€” Â¡Afinado!`;
                            } else if (diff > 0) {
                                indicator.style.background = "#f44336";
                                status.innerHTML = `ðŸ”» ${lastPitch.toFixed(2)} Hz - ${note} â€” Baja la tensiÃ³n`;
                            } else {
                                indicator.style.background = "#2196f3";
                                status.innerHTML = `ðŸ”º ${lastPitch.toFixed(2)} Hz - ${note} â€” Sube la tensiÃ³n`;
                            }
                        }

                        requestAnimationFrame(update);
                    }

                    update();
                })
                .catch(err => {
                    // Manejo de errores
                    console.error(err);
                    if (err.name === "NotAllowedError") {
                        document.getElementById('status').innerText = "Permiso de micrÃ³fono denegado. Por favor, habilÃ­talo en la configuraciÃ³n de tu telÃ©fono.";
                    } else {
                        document.getElementById('status').innerText = "Error accediendo al micrÃ³fono: " + err.message;
                    }
                });
        }

        // Solicitar permiso al cargar la pÃ¡gina
        // Verificar si el permiso ya fue concedido
        navigator.permissions.query({ name: 'microphone' })
            .then(permissionStatus => {
                if (permissionStatus.state === 'granted') {
                    // El permiso ya estÃ¡ concedido
                    requestMicrophonePermission();
                } else if (permissionStatus.state === 'prompt') {
                    // El permiso no ha sido concedido ni denegado, solicitarlo
                    requestMicrophonePermission();
                } else if (permissionStatus.state === 'denied') {
                    // El permiso ha sido denegado
                    document.getElementById('status').innerText = "Permiso de micrÃ³fono denegado. Por favor, habilÃ­talo en la configuraciÃ³n de tu telÃ©fono.";
                }
            });


        // Registro del Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js')
                .then(() => console.log("Service Worker registrado"));
        }
    </script>
</body>

</html>